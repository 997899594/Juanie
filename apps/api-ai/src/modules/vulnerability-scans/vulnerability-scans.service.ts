import { Injectable, Logger, BadRequestException, NotFoundException } from '@nestjs/common';
import { InjectDatabase } from '../../common/decorators/database.decorator';
import { Database } from '../../database/database.module';
import { eq, and, desc, asc, count, sql, ilike, inArray, gte, lte } from 'drizzle-orm';
import { 
  vulnerabilityScans,
  VulnerabilityScan,
  NewVulnerabilityScan,
  UpdateVulnerabilityScan,
  ScanType,
  TargetType,
  RiskLevelEnum,
  RemediationStatusEnum
} from '../../database/schemas/vulnerability-scans.schema';
import { projects } from '../../database/schemas/projects.schema';
import { repositories } from '../../database/schemas/repositories.schema';

export interface VulnerabilityScanStats {
  total: number;
  byScanType: Record<ScanType, number>;
  byRiskLevel: Record<string, number>;
  byRemediationStatus: Record<string, number>;
  averageRiskScore: number;
  totalVulnerabilities: number;
  remediationRate: number;
}

export interface VulnerabilityScanSearchFilters {
  projectId?: string;
  repositoryId?: string;
  scanType?: ScanType;
  targetType?: TargetType;
  overallRiskLevel?: string;
  remediationStatus?: string;
  minRiskScore?: number;
  maxRiskScore?: number;
  scannerName?: string;
  dateFrom?: Date;
  dateTo?: Date;
}

@Injectable()
export class VulnerabilityScansService {
  private readonly logger = new Logger(VulnerabilityScansService.name);

  constructor(
    @InjectDatabase() private readonly db: Database,
  ) {}

  // 创建漏洞扫描记录
  async createVulnerabilityScan(data: NewVulnerabilityScan): Promise<VulnerabilityScan> {
    const [scan] = await this.db
      .insert(vulnerabilityScans)
      .values(data)
      .returning();
    return scan;
  }

  // 根据ID获取漏洞扫描记录
  async getVulnerabilityScanById(id: string): Promise<VulnerabilityScan | null> {
    const [scan] = await this.db
      .select()
      .from(vulnerabilityScans)
      .where(eq(vulnerabilityScans.id, id))
      .limit(1);
    return scan || null;
  }

  // 根据项目ID获取漏洞扫描列表
  async getScansByProject(
    projectId: string,
    limit: number = 50,
    offset: number = 0
  ): Promise<VulnerabilityScan[]> {
    return await this.db
      .select()
      .from(vulnerabilityScans)
      .where(eq(vulnerabilityScans.projectId, projectId))
      .orderBy(desc(vulnerabilityScans.createdAt))
      .limit(limit)
      .offset(offset);
  }

  // 根据仓库ID获取漏洞扫描列表
  async getScansByRepository(
    repositoryId: string,
    limit: number = 50,
    offset: number = 0
  ): Promise<VulnerabilityScan[]> {
    return await this.db
      .select()
      .from(vulnerabilityScans)
      .where(eq(vulnerabilityScans.repositoryId, repositoryId))
      .orderBy(desc(vulnerabilityScans.createdAt))
      .limit(limit)
      .offset(offset);
  }

  // 根据扫描类型获取漏洞扫描列表
  async getScansByScanType(
    scanType: ScanType,
    limit: number = 50,
    offset: number = 0
  ): Promise<VulnerabilityScan[]> {
    return await this.db
      .select()
      .from(vulnerabilityScans)
      .where(eq(vulnerabilityScans.scanType, scanType))
      .orderBy(desc(vulnerabilityScans.createdAt))
      .limit(limit)
      .offset(offset);
  }

  // 根据风险级别获取漏洞扫描列表
  async getScansByRiskLevel(
    riskLevel: 'low' | 'medium' | 'high' | 'critical',
    limit: number = 50,
    offset: number = 0
  ): Promise<VulnerabilityScan[]> {
    return await this.db
      .select()
      .from(vulnerabilityScans)
      .where(eq(vulnerabilityScans.overallRiskLevel, riskLevel))
      .orderBy(desc(vulnerabilityScans.riskScore), desc(vulnerabilityScans.createdAt))
      .limit(limit)
      .offset(offset);
  }

  // 获取高风险扫描结果
  async getHighRiskScans(
    projectId?: string,
    repositoryId?: string,
    limit: number = 50,
    offset: number = 0
  ): Promise<VulnerabilityScan[]> {
    let whereConditions = [
      sql`${vulnerabilityScans.overallRiskLevel} IN ('high', 'critical')`
    ];

    if (projectId) {
      whereConditions.push(eq(vulnerabilityScans.projectId, projectId));
    }
    if (repositoryId) {
      whereConditions.push(eq(vulnerabilityScans.repositoryId, repositoryId));
    }

    return await this.db
      .select()
      .from(vulnerabilityScans)
      .where(and(...whereConditions))
      .orderBy(desc(vulnerabilityScans.riskScore), desc(vulnerabilityScans.createdAt))
      .limit(limit)
      .offset(offset);
  }

  // 获取待修复的扫描结果
  async getPendingRemediationScans(
    projectId?: string,
    repositoryId?: string,
    limit: number = 50,
    offset: number = 0
  ): Promise<VulnerabilityScan[]> {
    let whereConditions = [
      sql`${vulnerabilityScans.remediationStatus} IN ('pending', 'in_progress')`
    ];

    if (projectId) {
      whereConditions.push(eq(vulnerabilityScans.projectId, projectId));
    }
    if (repositoryId) {
      whereConditions.push(eq(vulnerabilityScans.repositoryId, repositoryId));
    }

    return await this.db
      .select()
      .from(vulnerabilityScans)
      .where(and(...whereConditions))
      .orderBy(desc(vulnerabilityScans.riskScore), desc(vulnerabilityScans.createdAt))
      .limit(limit)
      .offset(offset);
  }

  // 搜索漏洞扫描记录
  async searchScans(
    query: string,
    filters?: VulnerabilityScanSearchFilters,
    limit: number = 50,
    offset: number = 0
  ): Promise<VulnerabilityScan[]> {
    let whereConditions = [];

    // 文本搜索
    if (query) {
      whereConditions.push(
        sql`(${vulnerabilityScans.scannerName} ILIKE ${`%${query}%`} OR ${vulnerabilityScans.targetIdentifier} ILIKE ${`%${query}%`} OR ${vulnerabilityScans.aiAnalysisSummary} ILIKE ${`%${query}%`})`
      );
    }

    // 应用过滤器
    if (filters) {
      if (filters.projectId) {
        whereConditions.push(eq(vulnerabilityScans.projectId, filters.projectId));
      }
      if (filters.repositoryId) {
        whereConditions.push(eq(vulnerabilityScans.repositoryId, filters.repositoryId));
      }
      if (filters.scanType) {
        whereConditions.push(eq(vulnerabilityScans.scanType, filters.scanType));
      }
      if (filters.targetType) {
        whereConditions.push(eq(vulnerabilityScans.targetType, filters.targetType));
      }
      if (filters.overallRiskLevel) {
        whereConditions.push(eq(vulnerabilityScans.overallRiskLevel, filters.overallRiskLevel as 'low' | 'medium' | 'high' | 'critical'));
      }
      if (filters.remediationStatus) {
        whereConditions.push(eq(vulnerabilityScans.remediationStatus, filters.remediationStatus as 'pending' | 'in_progress' | 'completed' | 'false_positive' | 'accepted_risk'));
      }
      if (filters.minRiskScore !== undefined) {
        whereConditions.push(gte(vulnerabilityScans.riskScore, filters.minRiskScore));
      }
      if (filters.maxRiskScore !== undefined) {
        whereConditions.push(lte(vulnerabilityScans.riskScore, filters.maxRiskScore));
      }
      if (filters.scannerName) {
        whereConditions.push(eq(vulnerabilityScans.scannerName, filters.scannerName));
      }
      if (filters.dateFrom) {
        whereConditions.push(gte(vulnerabilityScans.createdAt, filters.dateFrom));
      }
      if (filters.dateTo) {
        whereConditions.push(lte(vulnerabilityScans.createdAt, filters.dateTo));
      }
    }

    const whereClause = whereConditions.length > 0 ? and(...whereConditions) : undefined;

    return await this.db
      .select()
      .from(vulnerabilityScans)
      .where(whereClause)
      .orderBy(desc(vulnerabilityScans.riskScore), desc(vulnerabilityScans.createdAt))
      .limit(limit)
      .offset(offset);
  }

  // 更新漏洞扫描记录
  async updateVulnerabilityScan(
    id: string,
    data: UpdateVulnerabilityScan
  ): Promise<VulnerabilityScan | null> {
    const [scan] = await this.db
      .update(vulnerabilityScans)
      .set(data)
      .where(eq(vulnerabilityScans.id, id))
      .returning();
    return scan || null;
  }

  // 更新修复状态
  async updateRemediationStatus(
    id: string,
    status: 'pending' | 'in_progress' | 'completed' | 'false_positive' | 'accepted_risk',
    progress?: number
  ): Promise<boolean> {
    const updateData: any = { remediationStatus: status };
    if (progress !== undefined) {
      updateData.remediationProgress = progress;
    }

    const result = await this.db
      .update(vulnerabilityScans)
      .set(updateData)
      .where(eq(vulnerabilityScans.id, id));
    
    // 对于Drizzle ORM，我们需要检查结果数组的长度
    return Array.isArray(result) ? result.length > 0 : true;
  }

  // 批量更新修复状态
  async batchUpdateRemediationStatus(
    ids: string[],
    status: 'pending' | 'in_progress' | 'completed' | 'false_positive' | 'accepted_risk'
  ): Promise<number> {
    const result = await this.db
      .update(vulnerabilityScans)
      .set({ remediationStatus: status })
      .where(inArray(vulnerabilityScans.id, ids));
    
    // 对于Drizzle ORM，返回受影响的行数需要不同的方法
    return Array.isArray(result) ? result.length : 0;
  }

  // 删除漏洞扫描记录
  async deleteVulnerabilityScan(id: string): Promise<boolean> {
    const result = await this.db
      .delete(vulnerabilityScans)
      .where(eq(vulnerabilityScans.id, id));
    
    // 对于Drizzle ORM，我们需要检查结果数组的长度
    return Array.isArray(result) ? result.length > 0 : true;
  }

  // 批量删除漏洞扫描记录
  async batchDeleteScans(ids: string[]): Promise<number> {
    const result = await this.db
      .delete(vulnerabilityScans)
      .where(inArray(vulnerabilityScans.id, ids));
    
    // 对于Drizzle ORM，返回受影响的行数需要不同的方法
    return Array.isArray(result) ? result.length : 0;
  }

  // 获取漏洞扫描统计信息
  async getScanStats(
    projectId?: string,
    repositoryId?: string
  ): Promise<VulnerabilityScanStats> {
    let whereConditions = [];

    if (projectId) {
      whereConditions.push(eq(vulnerabilityScans.projectId, projectId));
    }
    if (repositoryId) {
      whereConditions.push(eq(vulnerabilityScans.repositoryId, repositoryId));
    }

    const whereClause = whereConditions.length > 0 ? and(...whereConditions) : undefined;

    // 总数统计
    const [totalResult] = await this.db
      .select({ count: count() })
      .from(vulnerabilityScans)
      .where(whereClause);

    // 按扫描类型统计
    const scanTypeStats = await this.db
      .select({
        scanType: vulnerabilityScans.scanType,
        count: count(),
      })
      .from(vulnerabilityScans)
      .where(whereClause)
      .groupBy(vulnerabilityScans.scanType);

    // 按风险级别统计
    const riskLevelStats = await this.db
      .select({
        riskLevel: vulnerabilityScans.overallRiskLevel,
        count: count(),
      })
      .from(vulnerabilityScans)
      .where(whereClause)
      .groupBy(vulnerabilityScans.overallRiskLevel);

    // 按修复状态统计
    const remediationStats = await this.db
      .select({
        status: vulnerabilityScans.remediationStatus,
        count: count(),
      })
      .from(vulnerabilityScans)
      .where(whereClause)
      .groupBy(vulnerabilityScans.remediationStatus);

    // 平均风险分数和总漏洞数
    const [aggregateResult] = await this.db
      .select({
        avgRiskScore: sql<number>`AVG(${vulnerabilityScans.riskScore})`,
        totalVulns: sql<number>`SUM(${vulnerabilityScans.totalVulnerabilities})`,
        totalRemediated: sql<number>`SUM(${vulnerabilityScans.remediatedCount})`,
      })
      .from(vulnerabilityScans)
      .where(whereClause);

    const totalVulnerabilities = aggregateResult.totalVulns || 0;
    const totalRemediated = aggregateResult.totalRemediated || 0;
    const remediationRate = totalVulnerabilities > 0 ? (totalRemediated / totalVulnerabilities) * 100 : 0;

    return {
      total: totalResult.count,
      byScanType: {
        'sast': scanTypeStats.find(s => s.scanType === 'sast')?.count || 0,
        'dast': scanTypeStats.find(s => s.scanType === 'dast')?.count || 0,
        'dependency': scanTypeStats.find(s => s.scanType === 'dependency')?.count || 0,
        'container': scanTypeStats.find(s => s.scanType === 'container')?.count || 0,
        'infrastructure': scanTypeStats.find(s => s.scanType === 'infrastructure')?.count || 0,
      },
      byRiskLevel: {
        'low': riskLevelStats.find(s => s.riskLevel === 'low')?.count || 0,
        'medium': riskLevelStats.find(s => s.riskLevel === 'medium')?.count || 0,
        'high': riskLevelStats.find(s => s.riskLevel === 'high')?.count || 0,
        'critical': riskLevelStats.find(s => s.riskLevel === 'critical')?.count || 0,
      },
      byRemediationStatus: {
        'pending': remediationStats.find(s => s.status === 'pending')?.count || 0,
        'in_progress': remediationStats.find(s => s.status === 'in_progress')?.count || 0,
        'completed': remediationStats.find(s => s.status === 'completed')?.count || 0,
        'false_positive': remediationStats.find(s => s.status === 'false_positive')?.count || 0,
        'accepted_risk': remediationStats.find(s => s.status === 'accepted_risk')?.count || 0,
      },
      averageRiskScore: aggregateResult.avgRiskScore || 0,
      totalVulnerabilities,
      remediationRate,
    };
  }

  // 获取扫描数量
  async getScanCount(
    projectId?: string,
    repositoryId?: string,
    scanType?: ScanType,
    riskLevel?: 'low' | 'medium' | 'high' | 'critical'
  ): Promise<number> {
    let whereConditions = [];

    if (projectId) {
      whereConditions.push(eq(vulnerabilityScans.projectId, projectId));
    }
    if (repositoryId) {
      whereConditions.push(eq(vulnerabilityScans.repositoryId, repositoryId));
    }
    if (scanType) {
      whereConditions.push(eq(vulnerabilityScans.scanType, scanType));
    }
    if (riskLevel) {
      whereConditions.push(eq(vulnerabilityScans.overallRiskLevel, riskLevel));
    }

    const whereClause = whereConditions.length > 0 ? and(...whereConditions) : undefined;

    const [result] = await this.db
      .select({ count: count() })
      .from(vulnerabilityScans)
      .where(whereClause);

    return result.count;
  }

  // 获取扫描详情（包含项目和仓库信息）
  async getScanWithDetails(id: string): Promise<any> {
    const [result] = await this.db
      .select({
        scan: vulnerabilityScans,
        project: projects,
        repository: repositories,
      })
      .from(vulnerabilityScans)
      .leftJoin(projects, eq(vulnerabilityScans.projectId, projects.id))
      .leftJoin(repositories, eq(vulnerabilityScans.repositoryId, repositories.id))
      .where(eq(vulnerabilityScans.id, id))
      .limit(1);

    return result || null;
  }

  // 获取最新扫描结果
  async getLatestScans(
    projectId?: string,
    repositoryId?: string,
    scanType?: ScanType,
    limit: number = 10
  ): Promise<VulnerabilityScan[]> {
    let whereConditions = [];

    if (projectId) {
      whereConditions.push(eq(vulnerabilityScans.projectId, projectId));
    }
    if (repositoryId) {
      whereConditions.push(eq(vulnerabilityScans.repositoryId, repositoryId));
    }
    if (scanType) {
      whereConditions.push(eq(vulnerabilityScans.scanType, scanType));
    }

    const whereClause = whereConditions.length > 0 ? and(...whereConditions) : undefined;

    return await this.db
      .select()
      .from(vulnerabilityScans)
      .where(whereClause)
      .orderBy(desc(vulnerabilityScans.createdAt))
      .limit(limit);
  }

  // 获取扫描趋势数据
  async getScanTrends(
    projectId?: string,
    repositoryId?: string,
    days: number = 30
  ): Promise<any[]> {
    let whereConditions = [
      gte(vulnerabilityScans.createdAt, new Date(Date.now() - days * 24 * 60 * 60 * 1000))
    ];

    if (projectId) {
      whereConditions.push(eq(vulnerabilityScans.projectId, projectId));
    }
    if (repositoryId) {
      whereConditions.push(eq(vulnerabilityScans.repositoryId, repositoryId));
    }

    const whereClause = and(...whereConditions);

    return await this.db
      .select({
        date: sql<string>`DATE(${vulnerabilityScans.createdAt})`,
        scanCount: count(),
        avgRiskScore: sql<number>`AVG(${vulnerabilityScans.riskScore})`,
        totalVulns: sql<number>`SUM(${vulnerabilityScans.totalVulnerabilities})`,
      })
      .from(vulnerabilityScans)
      .where(whereClause)
      .groupBy(sql`DATE(${vulnerabilityScans.createdAt})`)
      .orderBy(sql`DATE(${vulnerabilityScans.createdAt})`);
  }

  // 验证扫描数据
  async validateScan(data: Partial<VulnerabilityScan>): Promise<{
    isValid: boolean;
    errors: string[];
  }> {
    const errors: string[] = [];

    // 验证必填字段
    if (data.scanType !== undefined && !['sast', 'dast', 'dependency', 'container', 'infrastructure'].includes(data.scanType)) {
      errors.push('Invalid scan type');
    }

    if (data.targetType !== undefined && !['code', 'container', 'deployment', 'infrastructure'].includes(data.targetType)) {
      errors.push('Invalid target type');
    }

    if (data.scannerName !== undefined && (!data.scannerName || data.scannerName.trim().length === 0)) {
      errors.push('Scanner name is required');
    }

    if (data.targetIdentifier !== undefined && (!data.targetIdentifier || data.targetIdentifier.trim().length === 0)) {
      errors.push('Target identifier is required');
    }

    // 验证数值范围
    if (data.riskScore !== undefined && data.riskScore !== null && (data.riskScore < 0 || data.riskScore > 100)) {
      errors.push('Risk score must be between 0 and 100');
    }

    if (data.totalVulnerabilities !== undefined && data.totalVulnerabilities !== null && data.totalVulnerabilities < 0) {
      errors.push('Total vulnerabilities cannot be negative');
    }

    // 验证项目ID是否存在
    if (data.projectId) {
      const [project] = await this.db
        .select({ id: projects.id })
        .from(projects)
        .where(eq(projects.id, data.projectId))
        .limit(1);
      
      if (!project) {
        errors.push('Project ID does not exist');
      }
    }

    // 验证仓库ID是否存在
    if (data.repositoryId) {
      const [repository] = await this.db
        .select({ id: repositories.id })
        .from(repositories)
        .where(eq(repositories.id, data.repositoryId))
        .limit(1);
      
      if (!repository) {
        errors.push('Repository ID does not exist');
      }
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }
}